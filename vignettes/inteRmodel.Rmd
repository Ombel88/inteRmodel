---
title: "inteRmodel"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{inteRmodel}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


# Introduction

The goal of inteRmodel is to provide the tools required to search for models in 
the generalized canonical correlations. 


```{r inteRmodel}
library(inteRmodel)
```


# Prepare

We use the data used on the vignette of the [RGCCA](https://cran.r-project.org/package=RGCCA) package.

```{r data}
data("ge_cgh_locIGR")
A <- ge_cgh_locIGR$multiblocks
Loc <- factor(ge_cgh_locIGR$y)
levels(Loc) <- colnames(ge_cgh_locIGR$multiblocks$y)
A[[3]] = A[[3]][, -3]
names(A)[3] <- "Loc"
```


# Design

The model is encoded in a design matrix. 
To ease the design there are several functions available.
The most important one is subSymm, which make substitutions on symmetric matrices.

```{r design}
C <- matrix(0, nrow = 3, ncol = 3, dimnames = list(names(A), names(A)))
model0 <- subSymm(C, "GE", "CGH", 1)
model0 <- subSymm(model0, "GE", "Loc", 1)
model0
```

Here we hypothesize that the Agriculture and the industry is linked and that the agriculture is linked with the political block.

# Design

Now we look for the model that best relates these data.

```{r search_model}
out_model <- search_model(A = A, c1 = c(.071,.2, 1), scheme = "horst",
               scale = FALSE, verbose = FALSE,
               ncomp = rep(1, length(A)),
               bias = TRUE)
```

This quickly explores over the 20 different models that could be the best ones.
We can see that our hypothesis is on the upper middle:
```{r hypotetical, echo=FALSE}
hist(out_model$AVE_inner, xlab = "inner AVE", 
     main = "Histogram of AVE_inner in the models", breaks = 20)
abline(v = out_model$AVE_inner[out_model$var12 == 0 & 
                                 out_model$var13 == 1 &  out_model$var23 == 1])
```

According to this a better model would be then:

```{r best}
columns <- grep("var", colnames(out_model))
model <- symm(C, out_model[which.max(out_model$AVE_inner), columns])
```

A model that instead of the expected relation between Agriculture and Industry block they are both related to the Political block. We further explore the relationship on this model:

```{r iterate_model}
out_best <- iterate_model(C = model, A = A, c1 = c(.071,.2, 1), 
                          scheme = "horst",
                          scale = FALSE, verbose = FALSE,
                          ncomp = rep(1, length(A)),
                          bias = TRUE)
```

We can see that usually the models is around 0.4 inner AVE.

```{r best_plot, echo=FALSE}
hist(out_best$AVE_inner, xlab = "inner AVE", 
     main = "Histogram of AVE_inner in the models")
```

The best model would be then:

```{r model2}
model2 <- symm(C, out_best[which.max(out_best$AVE_inner), columns])
model2
```


```{r boot, include = FALSE}
iterations <- 250
bs0 <- boot_sgcca(A, model0, c(.071,.2, 1), nb_boot = iterations)
bs1 <- boot_sgcca(A, model, c(.071,.2, 1), nb_boot = iterations)
bs2 <- boot_sgcca(A, model2, c(.071,.2, 1), nb_boot = iterations)
```
```{r boot2, eval=FALSE}
iterations <- 250
bs0 <- boot_sgcca(A, model0, c(.071,.2, 1), nb_boot = iterations)
bs1 <- boot_sgcca(A, model, c(.071,.2, 1), nb_boot = iterations)
bs2 <- boot_sgcca(A, model2, c(.071,.2, 1), nb_boot = iterations)
```

We can see that they have different distributions:

```{r boot_plot, echo=FALSE, message=FALSE}
plot(c(0.45, 0.9), c(0.05, 0.2), type = "n", xlab = "inner AVE", ylab = "outer AVE",
     main = "Bootstrap of models")
points(bs0$AVE, pch = 16, col = "red")
points(bs1$AVE, pch = 16, col = "green")
points(bs2$AVE, pch = 16)
legend("topright", legend = c("model2", "model", "model0"), 
       fill = c("black", "green", "red"))
```

# Features 

We can now analyze the canonical correlation for the weight of each variable.

```{r features}
m2 <- RGCCA::sgcca(A, model2, c1 = c(.071,.2, 1), scheme = "horst",
               scale = TRUE, verbose = FALSE, ncomp = rep(1, length(A)),
               bias = TRUE)
m0 <- RGCCA::sgcca(A, model0, c1 = c(.071,.2, 1), scheme = "horst",
               scale = TRUE, verbose = FALSE, ncomp = rep(1, length(A)),
               bias = TRUE)
```

We can now explore the position of each sample:

```{r m1}
pars <- par(mfrow = c(1, 2))
plot(m0$Y[[1]][, 1], m0$Y[[2]][, 1], type = "n", xlab = "Block1 Comp1", 
     ylab = "Block2 Comp1", main = "Initial model")
abline(h = 0, v = 0)
text(m0$Y[[1]][, 1], m0$Y[[2]][, 1], labels = Loc, col = as.numeric(Loc)+1)

plot(m2$Y[[1]][, 1], m2$Y[[2]][, 1], type = "n", xlab = "Block1 Comp1", 
     ylab = "Block2 Comp1", main = "Final model")
abline(h = 0, v = 0)
text(m2$Y[[1]][, 1], m2$Y[[2]][, 1], labels = Loc, col = as.numeric(Loc)+1)
par(pars)
```

Although the relative difference on the general outcome what have changed more is the 
importance of each variable. as we can see here:

```{r}
plot(m0$a$CGH[, 1], m2$a$CGH[, 1], main = "CGH variables importance", 
     xlab = "model0", ylab = "model2", pch = 16)
```

Where some variables that had a weight of 0 in model 0 become important and some variables that were important that no longer have any weight on the model 2.

As you can see the design influences on which variables can be used

# Session Info

```{r sessionInfo}
sessionInfo()
```

